# **Programowanie Obiektowe ‚Äì Java (2025Z)**

## **Klasa, obiekty, konstruktory**

### 1. Co to jest klasa?

> **Klasa** to **szablon (wzorzec)**, kt√≥ry opisuje, **jakie w≈Ça≈õciwo≈õci (pola)** i **zachowania (metody)** ma mieƒá obiekt.

Mo≈ºna to por√≥wnaƒá do **projektu domu** ‚Äî klasa opisuje, **co dom zawiera**, ale sam dom (czyli **obiekt**) trzeba jeszcze **zbudowaƒá**.

Przyk≈Çad z ≈ºycia:

* Klasa ‚Üí `Samoch√≥d`
* Obiekt ‚Üí *konkretne auto, np. jakie≈õ audi sƒÖsiada*, np. `Samoch√≥d audiSasiada = new Samoch√≥d();`

---

### 2. Sk≈Çadnia klasy w Javie

```java
public class NazwaKlasy {
    // Pola (atrybuty, w≈Ça≈õciwo≈õci)
    typ nazwaPola;

    // Konstruktor
    public NazwaKlasy() {
        // kod wykonywany przy tworzeniu obiektu
    }

    // Metody (zachowania)
    public void nazwaMetody() {
        // cia≈Ço metody
    }
}
```

---

### 3. Przyk≈Çad ‚Äì Klasa `Samochod`

```java
public class Samochod {
    // üî∏ Pola (cechy samochodu)
    String marka;
    String model;
    int rokProdukcji;
    double przebieg;

    // üî∏ Konstruktor (tworzy nowy obiekt)
    public Samochod(String marka, String model, int rokProdukcji, double przebieg) {
        this.marka = marka;
        this.model = model;
        this.rokProdukcji = rokProdukcji;
        this.przebieg = przebieg;
    }

    // üî∏ Metoda ‚Äì zachowanie samochodu
    public void uruchom() {
        System.out.println(marka + " " + model + " zosta≈Ç uruchomiony!");
    }

    public void wyswietlInformacje() {
        System.out.println("Marka: " + marka);
        System.out.println("Model: " + model);
        System.out.println("Rok: " + rokProdukcji);
        System.out.println("Przebieg: " + przebieg + " km");
    }
}
```

---

### 4. Tworzenie obiekt√≥w z klasy

Ka≈ºdy obiekt tworzy siƒô s≈Çowem kluczowym `new`.

```java
public class Main {
    public static void main(String[] args) {
        // Tworzymy dwa obiekty klasy Samochod
        Samochod auto1 = new Samochod("Toyota", "Corolla", 2018, 85000);
        Samochod auto2 = new Samochod("Audi", "A4", 2020, 42000);

        // Wywo≈Çanie metod obiekt√≥w
        auto1.uruchom();
        auto1.wyswietlInformacje();

        System.out.println();

        auto2.uruchom();
        auto2.wyswietlInformacje();
    }
}
```

**Wynik:**

```
Toyota Corolla zosta≈Ç uruchomiony!
Marka: Toyota
Model: Corolla
Rok: 2018
Przebieg: 85000.0 km

Audi A4 zosta≈Ç uruchomiony!
Marka: Audi
Model: A4
Rok: 2020
Przebieg: 42000.0 km
```

---

### 5. Kluczowe pojƒôcia

| Pojƒôcie              | Znaczenie                                                           |
| -------------------- | ------------------------------------------------------------------- |
| **Klasa**            | Szablon (wz√≥r) do tworzenia obiekt√≥w. Okre≈õla pola i metody.        |
| **Obiekt**           | Konkretna instancja klasy (czyli rzeczywisty "egzemplarz").         |
| **Pola (fields)**    | Zmienne wewnƒÖtrz klasy opisujƒÖce stan obiektu.                      |
| **Metody (methods)** | Funkcje wewnƒÖtrz klasy opisujƒÖce zachowanie obiektu.                |
| **Konstruktor**      | Specjalna metoda wywo≈Çywana przy tworzeniu obiektu (`new`).         |
| **this**             | S≈Çowo kluczowe wskazujƒÖce na aktualny obiekt (np. w konstruktorze). |

---

### 6. Przyk≈Çad z wykorzystaniem metod i logiki

```java
public class KontoBankowe {
    String wlasciciel;
    double saldo;

    public KontoBankowe(String wlasciciel, double saldoPoczatkowe) {
        this.wlasciciel = wlasciciel;
        this.saldo = saldoPoczatkowe;
    }

    public void wplata(double kwota) {
        saldo += kwota;
        System.out.println("Wp≈Çacono " + kwota + " z≈Ç. Nowe saldo: " + saldo);
    }

    public void wyplata(double kwota) {
        if (kwota <= saldo) {
            saldo -= kwota;
            System.out.println("Wyp≈Çacono " + kwota + " z≈Ç. Nowe saldo: " + saldo);
        } else {
            System.out.println("Brak ≈õrodk√≥w na koncie!");
        }
    }

    public void pokazSaldo() {
        System.out.println("Saldo konta " + wlasciciel + ": " + saldo + " z≈Ç");
    }
}
```

#### U≈ºycie w `main`:

```java
public class Main {
    public static void main(String[] args) {
        KontoBankowe konto = new KontoBankowe("Adrian", 1000);

        konto.pokazSaldo();
        konto.wplata(500);
        konto.wyplata(300);
        konto.wyplata(1500); // za du≈ºa kwota
    }
}
```

**Wynik:**

```
Saldo konta Adrian: 1000.0 z≈Ç
Wp≈Çacono 500.0 z≈Ç. Nowe saldo: 1500.0 z≈Ç
Wyp≈Çacono 300.0 z≈Ç. Nowe saldo: 1200.0 z≈Ç
Brak ≈õrodk√≥w na koncie!
```

---

#### S≈Çowa kluczowe w podstawach

| Element       | Co robi                                   |
| ------------- | ----------------------------------------- |
| `class`       | Definiuje nowy typ obiektowy (szablon).   |
| `object`      | Egzemplarz klasy tworzony przez `new`.    |
| `fields`      | Dane wewnƒôtrzne obiektu.                  |
| `methods`     | Zachowania obiektu.                       |
| `constructor` | Inicjalizuje pola obiektu przy tworzeniu. |
| `this`        | Odwo≈Çuje siƒô do bie≈ºƒÖcego obiektu.        |

## **Konstruktor w Javie (domy≈õlny, przeciƒÖ≈ºony, kopiujƒÖcy)**

### 1. Co to jest konstruktor?

**Konstruktor** to **specjalna metoda** w klasie, kt√≥ra **s≈Çu≈ºy do tworzenia i inicjalizacji obiekt√≥w**.
Uruchamia siƒô **automatycznie** w momencie, gdy tworzysz nowy obiekt za pomocƒÖ s≈Çowa kluczowego `new`.

---

### 2. Cechy konstruktora

| Cecha                                                                | Opis                                            |
| -------------------------------------------------------------------- | ----------------------------------------------- |
| Ma **takƒÖ samƒÖ nazwƒô jak klasa**                                     | np. klasa `Samochod` ‚Üí konstruktor `Samochod()` |
| **Nie ma typu zwracanego**                                           | nawet `void`                                    |
| Mo≈ºe przyjmowaƒá **parametry**                                        | aby ustawiƒá warto≈õci p√≥l przy tworzeniu obiektu |
| Mo≈ºna mieƒá **wiele konstruktor√≥w** (przeciƒÖ≈ºanie)                    |                                                 |
| Je≈õli nie zdefiniujesz ≈ºadnego, Java tworzy **domy≈õlny konstruktor** |                                                 |

---

### 3. Rodzaje konstruktor√≥w

#### A) Konstruktor domy≈õlny (bez parametr√≥w)

Je≈õli **nie napiszesz ≈ºadnego konstruktora**, Java automatycznie tworzy pusty konstruktor, kt√≥ry nic nie robi.

```java
public class Samochod {
    String marka;
    int rok;

    // Konstruktor domy≈õlny (Java tworzy go automatycznie)
}
```

U≈ºycie:

```java
Samochod auto = new Samochod();  // dzia≈Ça mimo ≈ºe nie napisali≈õmy konstruktora
```

Ale czƒôsto chcemy **napisaƒá go samodzielnie**, ≈ºeby nadaƒá warto≈õci domy≈õlne:

```java
public class Samochod {
    String marka;
    int rok;

    // Konstruktor domy≈õlny napisany rƒôcznie
    public Samochod() {
        marka = "Nieznana";
        rok = 2000;
    }

    public void info() {
        System.out.println("Marka: " + marka + ", rok: " + rok);
    }
}

public class Main {
    public static void main(String[] args) {
        Samochod auto = new Samochod();
        auto.info();
    }
}
```

**Wynik:**

```
Marka: Nieznana, rok: 2000
```

---

#### B) Konstruktor z parametrami

Pozwala ustawiƒá **warto≈õci p√≥l obiektu ju≈º w momencie tworzenia**.

```java
public class Samochod {
    String marka;
    int rok;

    // Konstruktor z parametrami
    public Samochod(String marka, int rok) {
        this.marka = marka;
        this.rok = rok;
    }

    public void info() {
        System.out.println("Marka: " + marka + ", rok: " + rok);
    }
}

public class Main {
    public static void main(String[] args) {
        Samochod auto1 = new Samochod("Toyota", 2018);
        Samochod auto2 = new Samochod("BMW", 2022);

        auto1.info();
        auto2.info();
    }
}
```

**Wynik:**

```
Marka: Toyota, rok: 2018
Marka: BMW, rok: 2022
```

Tutaj s≈Çowo kluczowe **`this`** oznacza *odwo≈Çanie do bie≈ºƒÖcego obiektu* ‚Äî dziƒôki temu `this.marka` i `this.rok` odnoszƒÖ siƒô do p√≥l klasy, a nie do zmiennych lokalnych o tej samej nazwie.

---

#### C) Konstruktor przeciƒÖ≈ºony

> **PrzeciƒÖ≈ºanie konstruktora** oznacza, ≈ºe w jednej klasie mo≈ºemy mieƒá **wiƒôcej ni≈º jeden konstruktor**, r√≥≈ºniƒÖcy siƒô **listƒÖ parametr√≥w**.

Java automatycznie rozpoznaje, kt√≥rego konstruktora u≈ºyƒá ‚Äî w zale≈ºno≈õci od liczby i typu przekazanych argument√≥w.

```java
public class Samochod {
    String marka;
    int rok;
    double przebieg;

    // Konstruktor 1 ‚Äì domy≈õlny
    public Samochod() {
        marka = "Nieznana";
        rok = 2000;
        przebieg = 0.0;
    }

    // Konstruktor 2 ‚Äì z dwoma parametrami
    public Samochod(String marka, int rok) {
        this.marka = marka;
        this.rok = rok;
        przebieg = 0.0;
    }

    // Konstruktor 3 ‚Äì z trzema parametrami
    public Samochod(String marka, int rok, double przebieg) {
        this.marka = marka;
        this.rok = rok;
        this.przebieg = przebieg;
    }

    public void info() {
        System.out.println("Marka: " + marka + ", rok: " + rok + ", przebieg: " + przebieg + " km");
    }
}

public class Main {
    public static void main(String[] args) {
        Samochod s1 = new Samochod();
        Samochod s2 = new Samochod("Honda", 2015);
        Samochod s3 = new Samochod("Audi", 2020, 55000);

        s1.info();
        s2.info();
        s3.info();
    }
}
```

**Wynik:**

```
Marka: Nieznana, rok: 2000, przebieg: 0.0 km
Marka: Honda, rok: 2015, przebieg: 0.0 km
Marka: Audi, rok: 2020, przebieg: 55000.0 km
```

---

#### D) Konstruktor kopiujƒÖcy

Nie jest wbudowany w Javƒô, ale mo≈ºna go **napisaƒá samodzielnie**, by utworzyƒá nowy obiekt **na podstawie innego obiektu tej samej klasy**.

```java
public class Samochod {
    String marka;
    int rok;

    // Konstruktor podstawowy
    public Samochod(String marka, int rok) {
        this.marka = marka;
        this.rok = rok;
    }

    // Konstruktor kopiujƒÖcy
    public Samochod(Samochod inny) {
        this.marka = inny.marka;
        this.rok = inny.rok;
    }

    public void info() {
        System.out.println("Marka: " + marka + ", rok: " + rok);
    }
}

public class Main {
    public static void main(String[] args) {
        Samochod oryginal = new Samochod("Mazda", 2019);
        Samochod kopia = new Samochod(oryginal); // tworzymy kopiƒô obiektu

        oryginal.info();
        kopia.info();
    }
}
```

**Wynik:**

```
Marka: Mazda, rok: 2019
Marka: Mazda, rok: 2019
```

---

### 4. Najczƒôstsze b≈Çƒôdy przy konstruktorach

| B≈ÇƒÖd                                                 | Co oznacza                                                        |
| ---------------------------------------------------- | ----------------------------------------------------------------- |
| Brak `this` w konstruktorze                          | Warto≈õci nie przypisujƒÖ siƒô do p√≥l klasy (zostajƒÖ `null` lub `0`) |
| Napisanie `void` przed konstruktorem                 | To ju≈º **nie konstruktor**, tylko **metoda o nazwie jak klasa**   |
| Pr√≥ba zwrotu warto≈õci z konstruktora                 | Konstruktor **nie mo≈ºe mieƒá typu zwracanego**                     |
| Brak konstruktora z parametrami, a pr√≥ba jego u≈ºycia | Java zwraca b≈ÇƒÖd ‚Äûconstructor not found‚Äù                          |

---

## **Metody w klasie ‚Äì rodzaje i zastosowania**

---

### 1. **Metody fabrykujƒÖce (Factory Methods)**

#### Definicja:

> **Metody fabrykujƒÖce** (ang. *factory methods*) to **statyczne metody**, kt√≥re **zwracajƒÖ gotowƒÖ instancjƒô klasy**.
> Nie tworzymy obiektu poprzez `new`, tylko przez specjalnƒÖ metodƒô np. `Person.create()`.

Czƒôsto u≈ºywa siƒô ich, aby:

* **Ukryƒá z≈Ço≈ºony proces tworzenia obiektu**
* **Zwracaƒá gotowe, skonfigurowane obiekty**
* **ZarzƒÖdzaƒá liczbƒÖ tworzonych obiekt√≥w** (np. wzorzec Singleton)

---

#### Przyk≈Çad:

```java
public class Samochod {
    private String marka;
    private String model;

    // Prywatny konstruktor ‚Äì nie mo≈ºna tworzyƒá obiekt√≥w przez new
    private Samochod(String marka, String model) {
        this.marka = marka;
        this.model = model;
    }

    // üî∏ Metoda fabrykujƒÖca (zwraca nowy obiekt)
    public static Samochod utworz(String marka, String model) {
        return new Samochod(marka, model);
    }

    public void info() {
        System.out.println("Samoch√≥d: " + marka + " " + model);
    }
}

public class Main {
    public static void main(String[] args) {
        // Tworzymy obiekt przez metodƒô fabrykujƒÖcƒÖ
        Samochod auto = Samochod.utworz("Audi", "A4");
        auto.info();
    }
}
```

**Wynik:**

```
Samoch√≥d: Audi A4
```

---

### 2. **Metody dostƒôpowe ‚Äì Gettery i Settery**

#### Definicja:

> Gettery i Settery to **metody s≈Çu≈ºƒÖce do bezpiecznego dostƒôpu do p√≥l klasy**, kt√≥re sƒÖ **ukryte (private)**.
> Dziƒôki nim realizujemy zasadƒô **enkapsulacji (hermetyzacji)**.

---

#### Przyk≈Çad:

```java
public class KontoBankowe {
    private String wlasciciel;
    private double saldo;

    public KontoBankowe(String wlasciciel, double saldoPoczatkowe) {
        this.wlasciciel = wlasciciel;
        this.saldo = saldoPoczatkowe;
    }

    // üîπ Getter ‚Äì zwraca warto≈õƒá pola
    public double getSaldo() {
        return saldo;
    }

    // üîπ Setter ‚Äì pozwala zmieniƒá warto≈õƒá pola
    public void setSaldo(double noweSaldo) {
        if (noweSaldo >= 0) {
            saldo = noweSaldo;
        } else {
            System.out.println("Saldo nie mo≈ºe byƒá ujemne!");
        }
    }

    public String getWlasciciel() {
        return wlasciciel;
    }
}
```

#### U≈ºycie:

```java
public class Main {
    public static void main(String[] args) {
        KontoBankowe konto = new KontoBankowe("Adrian", 1000);
        System.out.println("Saldo poczƒÖtkowe: " + konto.getSaldo());
        konto.setSaldo(1500);
        System.out.println("Nowe saldo: " + konto.getSaldo());
        konto.setSaldo(-200); // niepoprawne
    }
}
```

**Wynik:**

```
Saldo poczƒÖtkowe: 1000.0
Nowe saldo: 1500.0
Saldo nie mo≈ºe byƒá ujemne!
```

---

#### Wzorzec nazewnictwa getter√≥w i setter√≥w:

| Typ    | Nazwa metody                      | Przyk≈Çad dla pola `imie` |
| ------ | --------------------------------- | ------------------------ |
| Getter | `get` + nazwa pola z du≈ºej litery | `getImie()`              |
| Setter | `set` + nazwa pola z du≈ºej litery | `setImie(String imie)`   |

---

### 3. **Metody publiczne**

#### Definicja:

> **Publiczne metody** sƒÖ widoczne **dla wszystkich klas** ‚Äì niezale≈ºnie od pakietu.
> To w≈Ça≈õnie przez nie inne klasy mogƒÖ **komunikowaƒá siƒô** z obiektem.

---

#### Przyk≈Çad:

```java
public class Kalkulator {
    // Metoda publiczna ‚Äì dostƒôpna dla wszystkich
    public int dodaj(int a, int b) {
        return a + b;
    }

    public int odejmij(int a, int b) {
        return a - b;
    }
}

public class Main {
    public static void main(String[] args) {
        Kalkulator k = new Kalkulator();
        System.out.println(k.dodaj(10, 5));  // 15
        System.out.println(k.odejmij(10, 5)); // 5
    }
}
```

**Wynik:**

```
15
5
```

**Zastosowanie:**
Publiczne metody to *interfejs klasy* ‚Äì czyli spos√≥b, w jaki inne czƒô≈õci programu mogƒÖ z niƒÖ wsp√≥≈Çpracowaƒá.

---

### 4. **Metody chronione (protected)**

#### Definicja:

> Metody oznaczone jako `protected` sƒÖ **widoczne tylko dla:**
>
> * klasy, w kt√≥rej zosta≈Çy zdefiniowane,
> * **podklas** (nawet w innych pakietach),
> * **klas w tym samym pakiecie**.

---


**Zastosowanie:**
Metody `protected` sƒÖ idealne, gdy chcesz pozwoliƒá podklasom **rozszerzaƒá zachowanie klasy nadrzƒôdnej**, ale **nie udostƒôpniaƒá tego publicznie**.

---

### 5. **Metody prywatne (private)**

#### Definicja:

> **Prywatne metody** sƒÖ **widoczne tylko wewnƒÖtrz tej samej klasy**.
> Nie mo≈ºna ich wywo≈Çaƒá z zewnƒÖtrz ani z podklas.

---

#### Przyk≈Çad:

```java
class Uzytkownik {
    private String haslo;

    public Uzytkownik(String haslo) {
        this.haslo = haslo;
    }

    // Metoda prywatna
    private void pokazHaslo() {
        System.out.println("Has≈Ço: " + haslo);
    }

    // Metoda publiczna korzystajƒÖca z prywatnej
    public void zaloguj(String podaneHaslo) {
        System.out.println("Logowanie...");
        if( podaneHaslo.equals(this.haslo)){
            pokazHaslo(); // OK ‚Äì w tej samej klasie
        }
        else {
            System.out.println("B≈Çƒôdne has≈Ço...");
        }
    }
}

public class UzytkownikMain {
    public static void main(String[] args) {
        Uzytkownik u = new Uzytkownik("tajne1234");
        u.zaloguj("tajne1234");
        // u.pokazHaslo(); // B≈ÇƒÖd: metoda prywatna
    }
}
```

**Wynik:**

```
Logowanie...
Has≈Ço: tajne123
```

**Zastosowanie:**
Metody `private` s≈Çu≈ºƒÖ do **pomocniczych oblicze≈Ñ, walidacji lub konfiguracji**, kt√≥rych nie chcemy udostƒôpniaƒá innym klasom.


## Zadania
1.  Utw√≥rz klasƒô Dog z polami: name, breed i age. Napisz metodƒô bark(), kt√≥ra wydrukuje
    na konsoli "Wow Wow". Stw√≥rz przypadek testowy, aby wywo≈Çaƒá metodƒô co najmniej jeden
    raz.
2.  Utw√≥rz klasƒô Point z dwoma polami: x i y reprezentujƒÖcymi wsp√≥≈Çrzƒôdne na p≈Çaszczy≈∫nie.
    Napisz metodƒô distance(Point otherPoint), kt√≥ra oblicza odleg≈Ço≈õƒá miƒôdzy bie≈ºƒÖcym
    punktem a innym punktem. Stw√≥rz przypadek testowy, aby wywo≈Çaƒá metodƒô co najmniej
    jeden raz.
3.  Utw√≥rz klasƒô Person z publicznym polem name oraz prywatnym polem password. Zobacz
    jak r√≥≈ºne modyfikatory dostƒôpu wp≈ÇywajƒÖ na dostƒôp do tych p√≥l z innej klasy.
4. Stw√≥rz dwie klasy w tym samym pliku: Employee i Company. Klasa Employee powinna mieƒá pole bez modyfikatora dostƒôpu. Spr√≥buj uzyskaƒá dostƒôp do tego pola z klasy
   Company.
5.  Napisz klasƒô Book, kt√≥ra bƒôdzie zawieraƒá trzy pola: title, author, publicationYear.
    Nastƒôpnie zaimplementuj dwa konstruktory- jeden domy≈õlny, kt√≥ry nie przyjmuje ≈ºadnych argument√≥w, i drugi, kt√≥ry przyjmuje trzy argumenty odpowiadajƒÖce polom klasy.
    W przypadku drugiego konstruktora, nazwy parametr√≥w muszƒÖ byƒá takie same jak nazwy
    p√≥l. Sprawd≈∫ czy jeste≈õ w stanie prawid≈Çowo przypisaƒá warto≈õci do p√≥l klasy u≈ºywajƒÖc
    s≈Çowa kluczowego this.
6.  Stw√≥rz klasƒô Car, kt√≥ra bƒôdzie zawieraƒá trzy pola: brand, model, productionYear. Za
    implementuj trzy konstruktory- pierwszy domy≈õlny, drugi przyjmujƒÖcy dwa argumenty
    (brand i model), trzeci przyjmujƒÖcy trzy argumenty (brand, model, productionYear).
    W przypadku drugiego i trzeciego konstruktora, nazwy parametr√≥w muszƒÖ byƒá takie
    same jak nazwy p√≥l. Wykorzystaj s≈Çowo kluczowe this do rozr√≥≈ºnienia p√≥l klasy od
    parametr√≥w.
7.  Stw√≥rz klasƒô Television z prywatnymi polami: brand, screenDiagonal, resolution,
    isSmartTV oraz price. Dodaj konstruktor, kt√≥ry przyjmuje wszystkie pola jako argumenty. Dodaj metody dostƒôpowe (gettery i settery) oraz metodƒô showInformation(),
    kt√≥ra wy≈õwietla informacje o telewizorze.
8. Napisz klasƒô Osoba, kt√≥ra nie pozwala tworzyƒá obiektu przez konstruktor.
   Zamiast tego dodaj metodƒô fabrykujƒÖcƒÖ stworzOsobe, kt√≥ra zwraca nowy obiekt Osoba.
    Podpowied≈∫: Zastan√≥w siƒô, co mo≈ºesz zrobiƒá z konstruktorem, aby nie mieƒá dostƒôpu do konstruktora z zewnƒÖtrz klasy/obiektu.
9. Napisz klasƒô Kalkulator, kt√≥ra ma publicznƒÖ metodƒô obliczSume(int a, int b)
   i prywatnƒÖ metodƒô pomocniczƒÖ sprawdzDane(int a, int b),
   kt√≥ra sprawdza, czy liczby sƒÖ dodatnie.
   Je≈õli kt√≥ra≈õ liczba jest ujemna ‚Äì wypisz komunikat i zwr√≥ƒá false.
10. Wykonaj kolejno poni≈ºsze czynno≈õci:
      1. Stw√≥rz klasƒô Person z polem name. Dodaj do klasy metodƒô introduceYourself,
                kt√≥ra wy≈õwietli wiadomo≈õƒá ‚ÄúHi, I‚Äôm‚Äù i imiƒô osoby. W klasie TestPerson, utw√≥rz
                obiekt Person i wywo≈Çaj na nim metodƒô introduceYourself. Czy musisz u≈ºyƒá
                s≈Çowo kluczowe this w implementacji metody? 
      2. Dodaj do klasy Person metodƒô sayHello, kt√≥ra jako argument przyjmuje inny
                obiekt klasy Person i wy≈õwietla wiadomo≈õƒá ‚ÄúHello,‚Äù i imiƒô drugiej osoby. Przeanalizuj dzia≈Çanie. 
    3. Dodaj do klasy Person metodƒô changeName, kt√≥ra jako argument przyjmuje
                ≈Ça≈Ñcuch znak√≥w i przypisuje go do pola name. Utw√≥rz obiekt Person i u≈ºyj
                metody changeName do zmiany jego imienia. Nastƒôpnie wywo≈Çaj metodƒô
                introduceYourself. Czy imiƒô zosta≈Ço zmienione? Czy musisz u≈ºyƒá s≈Çowo
                kluczowe this w implementacji metody? 
    4. Dodaj do klasy Person metodƒô swapNames, kt√≥ra jako argument przyjmuje inny
                obiekt klasy Person i zamienia imionami obie osoby. Utw√≥rz dwa obiekty Person
                i u≈ºyj metody swapNames do zamiany ich imion. Nastƒôpnie wywo≈Çaj metodƒô
                introduceYourself na obu obiektach. Czy imiona zosta≈Çy zamienione?
